{"version":3,"file":"index.mjs","sources":["../src/format.js","../third_party/format.js","../src/constants.js","../src/resolve.js","../src/url.js","../src/parse.js"],"sourcesContent":["/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport qs from 'querystring';\nimport parse from './parse';\nimport format from '../third_party/format';\n\nconst slashedProtocols = /https?|ftp|gopher|file/;\n\nexport default function(urlObj) {\n  if (typeof urlObj === 'string') {\n    urlObj = parse(urlObj);\n  }\n\n  const { protocol, host, pathname, search, hash } = format(\n    urlObj,\n    qs,\n    slashedProtocols\n  );\n\n  return `${protocol}${host}${pathname}${search}${hash}`;\n}\n","// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport default function(urlObj, qs, slashedProtocols) {\n  let { auth, hostname } = urlObj;\n  let protocol = urlObj.protocol || '';\n  let pathname = urlObj.pathname || '';\n  let hash = urlObj.hash || '';\n  let query = urlObj.query || '';\n  let host = false;\n\n  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n\n  if (urlObj.host) {\n    host = auth + urlObj.host;\n  } else if (hostname) {\n    host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);\n    if (urlObj.port) {\n      host += ':' + urlObj.port;\n    }\n  }\n\n  if (query && typeof query === 'object') {\n    // query = '' + new URLSearchParams(query);\n    query = qs.encode(query);\n  }\n\n  let search = urlObj.search || (query && `?${query}`) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  if (\n    urlObj.slashes ||\n    ((!protocol || slashedProtocols.test(protocol)) && host !== false)\n  ) {\n    host = '//' + (host || '');\n    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash[0] !== '#') hash = '#' + hash;\n  if (search && search[0] !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n  search = search.replace('#', '%23');\n\n  return {\n    protocol,\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\n","/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const PROTOCOL = 'http://';\nexport const HOST = 'w.w';\nexport const BASE_URL = PROTOCOL + HOST;\n","/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport parse from './parse';\nimport format from './format';\nimport { BASE_URL, PROTOCOL, HOST } from './constants';\n\nconst resolveProtocolRegex = /^([a-z0-9.+-]*:\\/\\/\\/)([a-z0-9.+-]:\\/*)?/i;\nconst slashedProtocols = /https?|ftp|gopher|file/;\n\nexport function resolve(fromUrl, toUrl) {\n  let parsedFrom = typeof fromUrl === 'string' ? parse(fromUrl) : fromUrl;\n  fromUrl = typeof fromUrl === 'object' ? format(fromUrl) : fromUrl;\n  let parsedTo = parse(toUrl);\n  let prefix = '';\n\n  // Handle incomplete urls without slashes Eg: foo:a/b\n  if (parsedFrom.protocol && !parsedFrom.slashes) {\n    prefix = parsedFrom.protocol;\n\n    fromUrl = fromUrl.replace(parsedFrom.protocol, '');\n    prefix += toUrl[0] === '/' || fromUrl[0] === '/' ? '/' : '';\n  }\n\n  if (prefix && parsedTo.protocol) {\n    prefix = '';\n    if (!parsedTo.slashes) {\n      prefix = parsedTo.protocol;\n      toUrl = toUrl.replace(parsedTo.protocol, '');\n    }\n  }\n\n  // Handle http:///xyz urls\n  const protocolMatch = fromUrl.match(resolveProtocolRegex);\n  if (protocolMatch && !parsedTo.protocol) {\n    // protocolMatch[2] handles - file:///C:/DEV/Haskell/lib/HXmlToolbox-3.01/examples/\n    prefix = protocolMatch[1] + (protocolMatch[2] || '');\n    fromUrl = fromUrl.substr(prefix.length);\n\n    // :/// -> :// If toUrl is of the form //xyz\n    if (/^\\/\\/[^/]/.test(toUrl)) prefix = prefix.slice(0, -1);\n  }\n\n  const normalizedFromUrl = new URL(fromUrl, BASE_URL + '/');\n  let resolved = new URL(toUrl, normalizedFromUrl)\n    .toString()\n    .replace(BASE_URL, '');\n\n  // Remove/replace the protocol if the URL class has added it\n  let actualProtocol = parsedTo.protocol || parsedFrom.protocol;\n  actualProtocol += parsedFrom.slashes || parsedTo.slashes ? '//' : '';\n  if (!prefix && actualProtocol) {\n    resolved = resolved.replace(PROTOCOL, actualProtocol);\n  } else if (prefix) {\n    resolved = resolved.replace(PROTOCOL, '');\n  }\n\n  // Remove unwanted trailing slash\n  if (\n    !slashedProtocols.test(resolved) &&\n    !~toUrl.indexOf('.') &&\n    fromUrl.slice(-1) !== '/' &&\n    toUrl.slice(-1) !== '/' &&\n    resolved.slice(-1) === '/'\n  ) {\n    resolved = resolved.slice(0, -1);\n  }\n\n  // If prefix remove the leading slash\n  if (prefix) {\n    resolved = prefix + (resolved[0] === '/' ? resolved.substr(1) : resolved);\n  }\n\n  return resolved;\n}\n\nexport function resolveObject(fromUrl, toUrl) {\n  return parse(resolve(fromUrl, toUrl));\n}\n","/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport parse from './parse';\nimport format from './format';\nimport { resolve, resolveObject } from './resolve';\n\nexport default function Url() {}\nUrl.prototype.parse = parse;\nUrl.prototype.format = format;\nUrl.prototype.resolve = resolve;\nUrl.prototype.resolveObject = resolve;\n","/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport qs from 'querystring';\nimport format from './format';\nimport Url from './url';\nimport { BASE_URL, HOST } from './constants';\n\nconst slashedProtocols = /^https?|ftp|gopher|file/;\nconst urlRegex = /^(.*?)([#?].*)/;\nconst protocolRegex = /^([a-z0-9.+-]*:)(\\/{0,3})(.*)/i;\nconst slashesRegex = /^([a-z0-9.+-]*:)?\\/\\/\\/*/i;\nconst ipv6Regex = /^([a-z0-9.+-]*:)(\\/{0,2})\\[(.*)\\]$/i;\n\nfunction decodePath(url) {\n  return url\n    .replace(\n      /['^|`]/g,\n      (char) => '%' + char.charCodeAt().toString(16).toUpperCase()\n    )\n    .replace(/((?:%[0-9A-F]{2})+)/g, (_, seq) => {\n      try {\n        const decoded = decodeURIComponent(seq);\n        return decoded\n          .split('')\n          .map((char) => {\n            const code = char.charCodeAt();\n            if (code > 256 || /^[a-z0-9]$/i.test(char)) {\n              return char;\n            }\n            return '%' + code.toString(16).toUpperCase();\n          })\n          .join('');\n      } catch (_) {\n        return seq;\n      }\n    });\n}\n\nexport default function (urlStr, parseQs = false, slashesDenoteHost = false) {\n  if (urlStr && typeof urlStr === 'object' && urlStr instanceof Url) {\n    return urlStr;\n  }\n  urlStr = urlStr.trim();\n\n  const slashesMatch = urlStr.match(urlRegex);\n  if (slashesMatch) {\n    urlStr = slashesMatch[1].replace(/\\\\/g, '/') + slashesMatch[2];\n  } else {\n    urlStr = urlStr.replace(/\\\\/g, '/');\n  }\n\n  // IPv6 check\n  if (ipv6Regex.test(urlStr)) {\n    // Add trailing slash to IPV6 urls to match parsing\n    if (urlStr.slice(-1) !== '/') urlStr += '/';\n  }\n\n  const protocolMatch =\n    !/(^javascript)/.test(urlStr) && urlStr.match(protocolRegex);\n  let slashes = slashesRegex.test(urlStr);\n  let protocolPrefix = '';\n\n  if (protocolMatch) {\n    if (!slashedProtocols.test(protocolMatch[1])) {\n      // Replace invalid protocol with a valid one for correct parsing\n      protocolPrefix = protocolMatch[1].toLowerCase();\n      urlStr = `${protocolMatch[2]}${protocolMatch[3]}`;\n    }\n\n    if (!protocolMatch[2]) {\n      slashes = false;\n      if (slashedProtocols.test(protocolMatch[1])) {\n        protocolPrefix = protocolMatch[1];\n        urlStr = `${protocolMatch[3]}`;\n      } else {\n        urlStr = `//${protocolMatch[3]}`;\n      }\n    }\n\n    // Handle '///' in url Eg: http:///s//a/b/c\n    // TODO: file:/some/dir/# should become file:///some/dir/# according to the url module in node\n    if (protocolMatch[2].length === 3 || protocolMatch[2].length === 1) {\n      protocolPrefix = protocolMatch[1];\n      urlStr = `/${protocolMatch[3]}`;\n    }\n  }\n\n  let portMatch = (slashesMatch ? slashesMatch[1] : urlStr).match(\n    /^https?:\\/\\/[^/]+(:[0-9]+)(?=\\/|$)/\n  );\n  let portSuffix = portMatch && portMatch[1];\n\n  let url;\n  let res = new Url();\n  let err = '';\n  let preSlash = '';\n\n  try {\n    url = new URL(urlStr);\n  } catch (e) {\n    err = e;\n\n    // Handle url with slashes - Eg: //some_url\n    if (\n      !protocolPrefix &&\n      !slashesDenoteHost &&\n      /^\\/\\//.test(urlStr) &&\n      !/^\\/\\/.+[@.]/.test(urlStr)\n    ) {\n      preSlash = '/';\n      urlStr = urlStr.substr(1);\n    }\n\n    try {\n      url = new URL(urlStr, BASE_URL);\n    } catch (_) {\n      // Unable to parse the url\n      // If the URL has only the protocol - Eg: \"foo:\"\n      res.protocol = protocolPrefix;\n      res.href = protocolPrefix;\n      return res;\n    }\n  }\n\n  res.slashes = slashes && !preSlash;\n  res.host = url.host === HOST ? '' : url.host;\n  res.hostname =\n    url.hostname === HOST ? '' : url.hostname.replace(/(\\[|\\])/g, '');\n  res.protocol = err ? protocolPrefix || null : url.protocol;\n\n  res.search = url.search.replace(/\\\\/g, '%5C');\n  res.hash = url.hash.replace(/\\\\/g, '%5C');\n\n  const hashSplit = urlStr.split('#');\n  // Handle case when there is a lone '?' in url\n  // Eg: http://example.com/?\n  if (!res.search && ~hashSplit[0].indexOf('?')) {\n    res.search = '?';\n  }\n  // Similarly handle lone '#' Eg: http://example.com/#\n  if (!res.hash && hashSplit[1] === '') {\n    res.hash = '#';\n  }\n\n  // URLSearchParams is not supported in Edge 16\n  // res.query = res.searchParams;\n  res.query = parseQs ? qs.decode(url.search.substr(1)) : res.search.substr(1);\n\n  res.pathname =\n    preSlash + (protocolMatch ? decodePath(url.pathname) : url.pathname);\n\n  // Chrome parses \"#abc\" as \"about:blank#abc\"\n  if (res.protocol === 'about:' && res.pathname === 'blank') {\n    res.protocol = '';\n    res.pathname = '';\n  }\n\n  // Partial url that does not start with a /\n  // example www.example.com\n  if (err && urlStr[0] !== '/') res.pathname = res.pathname.substr(1);\n\n  // Remove additional trailing slashes added by URL\n  if (\n    protocolPrefix &&\n    !slashedProtocols.test(protocolPrefix) &&\n    urlStr.slice(-1) !== '/' &&\n    res.pathname === '/'\n  ) {\n    res.pathname = '';\n  }\n\n  res.path = res.pathname + res.search;\n\n  res.auth = [url.username, url.password]\n    .map(decodeURIComponent)\n    .filter(Boolean)\n    .join(':');\n  res.port = url.port;\n\n  // Make sure to include default ports if they were specified\n  if (portSuffix && !res.host.endsWith(portSuffix)) {\n    res.host += portSuffix;\n    res.port = portSuffix.slice(1);\n  }\n\n  res.href = preSlash ? `${res.pathname}${res.search}${res.hash}` : format(res);\n\n  const excludedKeys = /^(file)/.test(res.href) ? ['host', 'hostname'] : [];\n  Object.keys(res).forEach((k) => {\n    if (!~excludedKeys.indexOf(k)) res[k] = res[k] || null;\n  });\n\n  return res;\n}\n"],"names":["const","slashedProtocols","urlObj","parse","qs","auth","protocol","pathname","hash","query","host","encodeURIComponent","replace","hostname","indexOf","port","encode","search","substr","slashes","test","format","PROTOCOL","HOST","BASE_URL","resolveProtocolRegex","resolve","fromUrl","toUrl","parsedFrom","parsedTo","prefix","protocolMatch","match","length","slice","normalizedFromUrl","URL","resolved","toString","actualProtocol","resolveObject","Url","prototype","urlRegex","protocolRegex","slashesRegex","ipv6Regex","urlStr","parseQs","slashesDenoteHost","slashesMatch","trim","protocolPrefix","toLowerCase","url","portMatch","portSuffix","res","err","preSlash","e","_","href","hashSplit","split","decode","char","charCodeAt","toUpperCase","seq","decodeURIComponent","map","code","join","decodePath","path","username","password","filter","Boolean","endsWith","excludedKeys","Object","keys","forEach","k"],"mappings":"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"}