{"version":3,"sources":["../../../lib/typescript/runTypeCheck.ts"],"names":["runTypeCheck","ts","baseDir","tsConfigPath","effectiveConfiguration","fileNames","length","hasWarnings","requiredConfig","program","createProgram","options","noEmit","result","emit","regexIgnoredFile","allDiagnostics","getPreEmitDiagnostics","concat","diagnostics","filter","d","file","test","fileName","firstError","find","category","DiagnosticCategory","Error","Boolean","TypeScriptCompileError","warnings","Promise","all","Warning","map"],"mappings":"uEAAA,0DAIA,wEACA,gEACA,wEAOO,cAAeA,CAAAA,YAAf,CACLC,EADK,CAELC,OAFK,CAGLC,YAHK,CAIqB,0BAC1B,KAAMC,CAAAA,sBAAsB,CAAG,KAAM,2DACnCH,EADmC,CAEnCE,YAFmC,CAArC,CAKA,GAAIC,sBAAsB,CAACC,SAAvB,CAAiCC,MAAjC,CAA0C,CAA9C,CAAiD,CAC/C,MAAO,CAAEC,WAAW,CAAE,KAAf,CAAP,CACD,CACD,KAAMC,CAAAA,cAAc,CAAG,yDAAyBP,EAAzB,CAAvB,CAEA,KAAMQ,CAAAA,OAAO,CAAGR,EAAE,CAACS,aAAH,CAAiBN,sBAAsB,CAACC,SAAxC,CAAmD,CACjE,GAAGD,sBAAsB,CAACO,OADuC,CAEjE,GAAGH,cAF8D,CAGjEI,MAAM,CAAE,IAHyD,CAAnD,CAAhB,CAKA,KAAMC,CAAAA,MAAM,CAAGJ,OAAO,CAACK,IAAR,EAAf,CAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAMC,CAAAA,gBAAgB,CAAG,kEAAzB,CACA,KAAMC,CAAAA,cAAc,CAAGf,EAAE,CACtBgB,qBADoB,CACER,OADF,EAEpBS,MAFoB,CAEbL,MAAM,CAACM,WAFM,EAGpBC,MAHoB,CAGZC,CAAD,EAAO,EAAEA,CAAC,CAACC,IAAF,EAAUP,gBAAgB,CAACQ,IAAjB,CAAsBF,CAAC,CAACC,IAAF,CAAOE,QAA7B,CAAZ,CAHM,CAAvB,CAKA,KAAMC,CAAAA,UAAU,uBACdT,cAAc,CAACU,IAAf,CACGL,CAAD,EAAOA,CAAC,CAACM,QAAF,GAAeC,wCAAmBC,KAAlC,EAA2CC,OAAO,CAACT,CAAC,CAACC,IAAH,CAD3D,CADc,6BAGTN,cAAc,CAACU,IAAf,CAAqBL,CAAD,EAAOA,CAAC,CAACM,QAAF,GAAeC,wCAAmBC,KAA7D,CAHP,CAKA,GAAIJ,UAAJ,CAAgB,CACd,KAAM,IAAIM,+CAAJ,CACJ,KAAM,gDAAuB9B,EAAvB,CAA2BC,OAA3B,CAAoCuB,UAApC,CADF,CAAN,CAGD,CAED,KAAMO,CAAAA,QAAQ,CAAG,KAAMC,CAAAA,OAAO,CAACC,GAAR,CACrBlB,cAAc,CACXI,MADH,CACWC,CAAD,EAAOA,CAAC,CAACM,QAAF,GAAeC,wCAAmBO,OADnD,EAEGC,GAFH,CAEQf,CAAD,EAAO,gDAAuBpB,EAAvB,CAA2BC,OAA3B,CAAoCmB,CAApC,CAFd,CADqB,CAAvB,CAKA,MAAO,CAAEd,WAAW,CAAE,IAAf,CAAqByB,QAArB,CAAP,CACD","sourcesContent":["import {\n  DiagnosticCategory,\n  getFormattedDiagnostic,\n} from './diagnosticFormatter'\nimport { getTypeScriptConfiguration } from './getTypeScriptConfiguration'\nimport { TypeScriptCompileError } from './TypeScriptCompileError'\nimport { getRequiredConfiguration } from './writeConfigurationDefaults'\n\nexport interface TypeCheckResult {\n  hasWarnings: boolean\n  warnings?: string[]\n}\n\nexport async function runTypeCheck(\n  ts: typeof import('typescript'),\n  baseDir: string,\n  tsConfigPath: string\n): Promise<TypeCheckResult> {\n  const effectiveConfiguration = await getTypeScriptConfiguration(\n    ts,\n    tsConfigPath\n  )\n\n  if (effectiveConfiguration.fileNames.length < 1) {\n    return { hasWarnings: false }\n  }\n  const requiredConfig = getRequiredConfiguration(ts)\n\n  const program = ts.createProgram(effectiveConfiguration.fileNames, {\n    ...effectiveConfiguration.options,\n    ...requiredConfig,\n    noEmit: true,\n  })\n  const result = program.emit()\n\n  // Intended to match:\n  // - pages/test.js\n  // - pages/apples.test.js\n  // - pages/__tests__/a.js\n  //\n  // But not:\n  // - pages/contest.js\n  // - pages/other.js\n  // - pages/test/a.js\n  //\n  const regexIgnoredFile = /[\\\\/]__(?:tests|mocks)__[\\\\/]|(?<=[\\\\/.])(?:spec|test)\\.[^\\\\/]+$/\n  const allDiagnostics = ts\n    .getPreEmitDiagnostics(program)\n    .concat(result.diagnostics)\n    .filter((d) => !(d.file && regexIgnoredFile.test(d.file.fileName)))\n\n  const firstError =\n    allDiagnostics.find(\n      (d) => d.category === DiagnosticCategory.Error && Boolean(d.file)\n    ) ?? allDiagnostics.find((d) => d.category === DiagnosticCategory.Error)\n\n  if (firstError) {\n    throw new TypeScriptCompileError(\n      await getFormattedDiagnostic(ts, baseDir, firstError)\n    )\n  }\n\n  const warnings = await Promise.all(\n    allDiagnostics\n      .filter((d) => d.category === DiagnosticCategory.Warning)\n      .map((d) => getFormattedDiagnostic(ts, baseDir, d))\n  )\n  return { hasWarnings: true, warnings }\n}\n"]}