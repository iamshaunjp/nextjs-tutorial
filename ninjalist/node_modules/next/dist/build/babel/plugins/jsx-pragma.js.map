{"version":3,"sources":["../../../../build/babel/plugins/jsx-pragma.ts"],"names":["types","t","inherits","jsx","visitor","JSXElement","_path","state","set","JSXFragment","Program","exit","path","get","pragma","identifier","opts","importAs","existingBinding","reuseImport","scope","getBinding","property","generateUidIdentifier","mapping","variableDeclaration","variableDeclarator","memberExpression","newPath","isVariableDeclarator","node","isCallExpression","init","isIdentifier","callee","name","parentPath","insertAfter","unshiftContainer","declar","registerBinding","kind","importSpecifier","importDeclaration","import","importNamespace","importNamespaceSpecifier","importDefaultSpecifier","stringLiteral","module","specifier"],"mappings":"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","sourcesContent":["import {\n  NodePath,\n  PluginObj,\n  types as BabelTypes,\n} from 'next/dist/compiled/babel/core'\nimport jsx from 'next/dist/compiled/babel/plugin-syntax-jsx'\n\nexport default function ({\n  types: t,\n}: {\n  types: typeof BabelTypes\n}): PluginObj<any> {\n  return {\n    inherits: jsx,\n    visitor: {\n      JSXElement(_path, state) {\n        state.set('jsx', true)\n      },\n\n      // Fragment syntax is still JSX since it compiles to createElement(),\n      // but JSXFragment is not a JSXElement\n      JSXFragment(_path, state) {\n        state.set('jsx', true)\n      },\n\n      Program: {\n        exit(path: NodePath<BabelTypes.Program>, state) {\n          if (state.get('jsx')) {\n            const pragma = t.identifier(state.opts.pragma)\n            let importAs = pragma\n\n            // if there's already a React in scope, use that instead of adding an import\n            const existingBinding =\n              state.opts.reuseImport !== false &&\n              state.opts.importAs &&\n              path.scope.getBinding(state.opts.importAs)\n\n            // var _jsx = _pragma.createElement;\n            if (state.opts.property) {\n              if (state.opts.importAs) {\n                importAs = t.identifier(state.opts.importAs)\n              } else {\n                importAs = path.scope.generateUidIdentifier('pragma')\n              }\n\n              const mapping = t.variableDeclaration('var', [\n                t.variableDeclarator(\n                  pragma,\n                  t.memberExpression(\n                    importAs,\n                    t.identifier(state.opts.property)\n                  )\n                ),\n              ])\n\n              // if the React binding came from a require('react'),\n              // make sure that our usage comes after it.\n              let newPath: NodePath<BabelTypes.VariableDeclaration>\n\n              if (\n                existingBinding &&\n                t.isVariableDeclarator(existingBinding.path.node) &&\n                t.isCallExpression(existingBinding.path.node.init) &&\n                t.isIdentifier(existingBinding.path.node.init.callee) &&\n                existingBinding.path.node.init.callee.name === 'require'\n              ) {\n                ;[newPath] = existingBinding.path.parentPath.insertAfter(\n                  mapping\n                )\n              } else {\n                ;[newPath] = path.unshiftContainer('body', mapping)\n              }\n\n              for (const declar of newPath.get('declarations')) {\n                path.scope.registerBinding(\n                  newPath.node.kind,\n                  declar as NodePath<BabelTypes.Node>\n                )\n              }\n            }\n\n            if (!existingBinding) {\n              const importSpecifier = t.importDeclaration(\n                [\n                  state.opts.import\n                    ? // import { $import as _pragma } from '$module'\n                      t.importSpecifier(\n                        importAs,\n                        t.identifier(state.opts.import)\n                      )\n                    : state.opts.importNamespace\n                    ? t.importNamespaceSpecifier(importAs)\n                    : // import _pragma from '$module'\n                      t.importDefaultSpecifier(importAs),\n                ],\n                t.stringLiteral(state.opts.module || 'react')\n              )\n\n              const [newPath] = path.unshiftContainer('body', importSpecifier)\n              for (const specifier of newPath.get('specifiers')) {\n                path.scope.registerBinding(\n                  'module',\n                  specifier as NodePath<BabelTypes.Node>\n                )\n              }\n            }\n          }\n        },\n      },\n    },\n  }\n}\n"]}