{"version":3,"sources":["../../../../build/babel/plugins/next-ssg-transform.ts"],"names":["EXPORT_NAME_GET_STATIC_PROPS","EXPORT_NAME_GET_STATIC_PATHS","EXPORT_NAME_GET_SERVER_PROPS","ssgExports","Set","decorateSsgExport","t","path","state","gsspName","isPrerender","STATIC_PROPS_ID","SERVER_PROPS_ID","gsspId","identifier","addGsspExport","exportPath","done","pageCompPath","replaceWithMultiple","exportNamedDeclaration","variableDeclaration","variableDeclarator","booleanLiteral","exportSpecifier","node","scope","registerDeclaration","traverse","ExportDefaultDeclaration","exportDefaultPath","ExportNamedDeclaration","exportNamedPath","isDataIdentifier","name","has","Error","SERVER_PROPS_SSG_CONFLICT","isServerProps","nextTransformSsg","types","getIdentifier","parentPath","type","pp","get","id","isIdentifierReferenced","ident","b","getBinding","referenced","constantViolations","concat","referencePaths","every","ref","findParent","p","markFunction","refs","add","markImport","local","visitor","Program","enter","VariableDeclarator","variablePath","variableState","pattern","properties","forEach","elements","e","FunctionDeclaration","FunctionExpression","ArrowFunctionExpression","ImportSpecifier","ImportDefaultSpecifier","ImportNamespaceSpecifier","exportNamedState","specifiers","length","s","isIdentifier","exported","value","remove","decl","inner","d","count","sweepFunction","sweepPath","isAssignmentExpression","isVariableDeclarator","sweepImport","parent","crawl","beforeCount"],"mappings":"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","sourcesContent":["import {\n  NodePath,\n  PluginObj,\n  types as BabelTypes,\n} from 'next/dist/compiled/babel/core'\nimport { SERVER_PROPS_SSG_CONFLICT } from '../../../lib/constants'\nimport {\n  SERVER_PROPS_ID,\n  STATIC_PROPS_ID,\n} from '../../../next-server/lib/constants'\n\nexport const EXPORT_NAME_GET_STATIC_PROPS = 'getStaticProps'\nexport const EXPORT_NAME_GET_STATIC_PATHS = 'getStaticPaths'\nexport const EXPORT_NAME_GET_SERVER_PROPS = 'getServerSideProps'\n\nconst ssgExports = new Set([\n  EXPORT_NAME_GET_STATIC_PROPS,\n  EXPORT_NAME_GET_STATIC_PATHS,\n  EXPORT_NAME_GET_SERVER_PROPS,\n\n  // legacy methods added so build doesn't fail from importing\n  // server-side only methods\n  `unstable_getStaticProps`,\n  `unstable_getStaticPaths`,\n  `unstable_getServerProps`,\n  `unstable_getServerSideProps`,\n])\n\ntype PluginState = {\n  refs: Set<NodePath<BabelTypes.Identifier>>\n  isPrerender: boolean\n  isServerProps: boolean\n  done: boolean\n}\n\nfunction decorateSsgExport(\n  t: typeof BabelTypes,\n  path: NodePath<BabelTypes.Program>,\n  state: PluginState\n): void {\n  const gsspName = state.isPrerender ? STATIC_PROPS_ID : SERVER_PROPS_ID\n  const gsspId = t.identifier(gsspName)\n\n  const addGsspExport = (\n    exportPath:\n      | NodePath<BabelTypes.ExportDefaultDeclaration>\n      | NodePath<BabelTypes.ExportNamedDeclaration>\n  ): void => {\n    if (state.done) {\n      return\n    }\n    state.done = true\n\n    const [pageCompPath] = exportPath.replaceWithMultiple([\n      t.exportNamedDeclaration(\n        t.variableDeclaration(\n          // We use 'var' instead of 'let' or 'const' for ES5 support. Since\n          // this runs in `Program#exit`, no ES2015 transforms (preset env)\n          // will be ran against this code.\n          'var',\n          [t.variableDeclarator(gsspId, t.booleanLiteral(true))]\n        ),\n        [t.exportSpecifier(gsspId, gsspId)]\n      ),\n      exportPath.node,\n    ])\n    exportPath.scope.registerDeclaration(\n      pageCompPath as NodePath<BabelTypes.Node>\n    )\n  }\n\n  path.traverse({\n    ExportDefaultDeclaration(exportDefaultPath) {\n      addGsspExport(exportDefaultPath)\n    },\n    ExportNamedDeclaration(exportNamedPath) {\n      addGsspExport(exportNamedPath)\n    },\n  })\n}\n\nconst isDataIdentifier = (name: string, state: PluginState): boolean => {\n  if (ssgExports.has(name)) {\n    if (name === EXPORT_NAME_GET_SERVER_PROPS) {\n      if (state.isPrerender) {\n        throw new Error(SERVER_PROPS_SSG_CONFLICT)\n      }\n      state.isServerProps = true\n    } else {\n      if (state.isServerProps) {\n        throw new Error(SERVER_PROPS_SSG_CONFLICT)\n      }\n      state.isPrerender = true\n    }\n    return true\n  }\n  return false\n}\n\nexport default function nextTransformSsg({\n  types: t,\n}: {\n  types: typeof BabelTypes\n}): PluginObj<PluginState> {\n  function getIdentifier(\n    path:\n      | NodePath<BabelTypes.FunctionDeclaration>\n      | NodePath<BabelTypes.FunctionExpression>\n      | NodePath<BabelTypes.ArrowFunctionExpression>\n  ): NodePath<BabelTypes.Identifier> | null {\n    const parentPath = path.parentPath\n    if (parentPath.type === 'VariableDeclarator') {\n      const pp = parentPath as NodePath<BabelTypes.VariableDeclarator>\n      const name = pp.get('id')\n      return name.node.type === 'Identifier'\n        ? (name as NodePath<BabelTypes.Identifier>)\n        : null\n    }\n\n    if (parentPath.type === 'AssignmentExpression') {\n      const pp = parentPath as NodePath<BabelTypes.AssignmentExpression>\n      const name = pp.get('left')\n      return name.node.type === 'Identifier'\n        ? (name as NodePath<BabelTypes.Identifier>)\n        : null\n    }\n\n    if (path.node.type === 'ArrowFunctionExpression') {\n      return null\n    }\n\n    return path.node.id && path.node.id.type === 'Identifier'\n      ? (path.get('id') as NodePath<BabelTypes.Identifier>)\n      : null\n  }\n\n  function isIdentifierReferenced(\n    ident: NodePath<BabelTypes.Identifier>\n  ): boolean {\n    const b = ident.scope.getBinding(ident.node.name)\n    if (b?.referenced) {\n      // Functions can reference themselves, so we need to check if there's a\n      // binding outside the function scope or not.\n      if (b.path.type === 'FunctionDeclaration') {\n        return !b.constantViolations\n          .concat(b.referencePaths)\n          // Check that every reference is contained within the function:\n          .every((ref) => ref.findParent((p) => p === b.path))\n      }\n\n      return true\n    }\n    return false\n  }\n\n  function markFunction(\n    path:\n      | NodePath<BabelTypes.FunctionDeclaration>\n      | NodePath<BabelTypes.FunctionExpression>\n      | NodePath<BabelTypes.ArrowFunctionExpression>,\n    state: PluginState\n  ): void {\n    const ident = getIdentifier(path)\n    if (ident?.node && isIdentifierReferenced(ident)) {\n      state.refs.add(ident)\n    }\n  }\n\n  function markImport(\n    path:\n      | NodePath<BabelTypes.ImportSpecifier>\n      | NodePath<BabelTypes.ImportDefaultSpecifier>\n      | NodePath<BabelTypes.ImportNamespaceSpecifier>,\n    state: PluginState\n  ): void {\n    const local = path.get('local') as NodePath<BabelTypes.Identifier>\n    if (isIdentifierReferenced(local)) {\n      state.refs.add(local)\n    }\n  }\n\n  return {\n    visitor: {\n      Program: {\n        enter(path, state) {\n          state.refs = new Set<NodePath<BabelTypes.Identifier>>()\n          state.isPrerender = false\n          state.isServerProps = false\n          state.done = false\n\n          path.traverse(\n            {\n              VariableDeclarator(variablePath, variableState) {\n                if (variablePath.node.id.type === 'Identifier') {\n                  const local = variablePath.get('id') as NodePath<\n                    BabelTypes.Identifier\n                  >\n                  if (isIdentifierReferenced(local)) {\n                    variableState.refs.add(local)\n                  }\n                } else if (variablePath.node.id.type === 'ObjectPattern') {\n                  const pattern = variablePath.get('id') as NodePath<\n                    BabelTypes.ObjectPattern\n                  >\n\n                  const properties = pattern.get('properties')\n                  properties.forEach((p) => {\n                    const local = p.get(\n                      p.node.type === 'ObjectProperty'\n                        ? 'value'\n                        : p.node.type === 'RestElement'\n                        ? 'argument'\n                        : (function () {\n                            throw new Error('invariant')\n                          })()\n                    ) as NodePath<BabelTypes.Identifier>\n                    if (isIdentifierReferenced(local)) {\n                      variableState.refs.add(local)\n                    }\n                  })\n                } else if (variablePath.node.id.type === 'ArrayPattern') {\n                  const pattern = variablePath.get('id') as NodePath<\n                    BabelTypes.ArrayPattern\n                  >\n\n                  const elements = pattern.get('elements')\n                  elements.forEach((e) => {\n                    let local: NodePath<BabelTypes.Identifier>\n                    if (e.node?.type === 'Identifier') {\n                      local = e as NodePath<BabelTypes.Identifier>\n                    } else if (e.node?.type === 'RestElement') {\n                      local = e.get('argument') as NodePath<\n                        BabelTypes.Identifier\n                      >\n                    } else {\n                      return\n                    }\n\n                    if (isIdentifierReferenced(local)) {\n                      variableState.refs.add(local)\n                    }\n                  })\n                }\n              },\n              FunctionDeclaration: markFunction,\n              FunctionExpression: markFunction,\n              ArrowFunctionExpression: markFunction,\n              ImportSpecifier: markImport,\n              ImportDefaultSpecifier: markImport,\n              ImportNamespaceSpecifier: markImport,\n              ExportNamedDeclaration(exportNamedPath, exportNamedState) {\n                const specifiers = exportNamedPath.get('specifiers')\n                if (specifiers.length) {\n                  specifiers.forEach((s) => {\n                    if (\n                      isDataIdentifier(\n                        t.isIdentifier(s.node.exported)\n                          ? s.node.exported.name\n                          : s.node.exported.value,\n                        exportNamedState\n                      )\n                    ) {\n                      s.remove()\n                    }\n                  })\n\n                  if (exportNamedPath.node.specifiers.length < 1) {\n                    exportNamedPath.remove()\n                  }\n                  return\n                }\n\n                const decl = exportNamedPath.get('declaration') as NodePath<\n                  | BabelTypes.FunctionDeclaration\n                  | BabelTypes.VariableDeclaration\n                >\n                if (decl == null || decl.node == null) {\n                  return\n                }\n\n                switch (decl.node.type) {\n                  case 'FunctionDeclaration': {\n                    const name = decl.node.id!.name\n                    if (isDataIdentifier(name, exportNamedState)) {\n                      exportNamedPath.remove()\n                    }\n                    break\n                  }\n                  case 'VariableDeclaration': {\n                    const inner = decl.get('declarations') as NodePath<\n                      BabelTypes.VariableDeclarator\n                    >[]\n                    inner.forEach((d) => {\n                      if (d.node.id.type !== 'Identifier') {\n                        return\n                      }\n                      const name = d.node.id.name\n                      if (isDataIdentifier(name, exportNamedState)) {\n                        d.remove()\n                      }\n                    })\n                    break\n                  }\n                  default: {\n                    break\n                  }\n                }\n              },\n            },\n            state\n          )\n\n          if (!state.isPrerender && !state.isServerProps) {\n            return\n          }\n\n          const refs = state.refs\n          let count: number\n\n          function sweepFunction(\n            sweepPath:\n              | NodePath<BabelTypes.FunctionDeclaration>\n              | NodePath<BabelTypes.FunctionExpression>\n              | NodePath<BabelTypes.ArrowFunctionExpression>\n          ): void {\n            const ident = getIdentifier(sweepPath)\n            if (\n              ident?.node &&\n              refs.has(ident) &&\n              !isIdentifierReferenced(ident)\n            ) {\n              ++count\n\n              if (\n                t.isAssignmentExpression(sweepPath.parentPath) ||\n                t.isVariableDeclarator(sweepPath.parentPath)\n              ) {\n                sweepPath.parentPath.remove()\n              } else {\n                sweepPath.remove()\n              }\n            }\n          }\n\n          function sweepImport(\n            sweepPath:\n              | NodePath<BabelTypes.ImportSpecifier>\n              | NodePath<BabelTypes.ImportDefaultSpecifier>\n              | NodePath<BabelTypes.ImportNamespaceSpecifier>\n          ): void {\n            const local = sweepPath.get('local') as NodePath<\n              BabelTypes.Identifier\n            >\n            if (refs.has(local) && !isIdentifierReferenced(local)) {\n              ++count\n              sweepPath.remove()\n              if (\n                (sweepPath.parent as BabelTypes.ImportDeclaration).specifiers\n                  .length === 0\n              ) {\n                sweepPath.parentPath.remove()\n              }\n            }\n          }\n\n          do {\n            ;(path.scope as any).crawl()\n            count = 0\n\n            path.traverse({\n              // eslint-disable-next-line no-loop-func\n              VariableDeclarator(variablePath) {\n                if (variablePath.node.id.type === 'Identifier') {\n                  const local = variablePath.get('id') as NodePath<\n                    BabelTypes.Identifier\n                  >\n                  if (refs.has(local) && !isIdentifierReferenced(local)) {\n                    ++count\n                    variablePath.remove()\n                  }\n                } else if (variablePath.node.id.type === 'ObjectPattern') {\n                  const pattern = variablePath.get('id') as NodePath<\n                    BabelTypes.ObjectPattern\n                  >\n\n                  const beforeCount = count\n                  const properties = pattern.get('properties')\n                  properties.forEach((p) => {\n                    const local = p.get(\n                      p.node.type === 'ObjectProperty'\n                        ? 'value'\n                        : p.node.type === 'RestElement'\n                        ? 'argument'\n                        : (function () {\n                            throw new Error('invariant')\n                          })()\n                    ) as NodePath<BabelTypes.Identifier>\n\n                    if (refs.has(local) && !isIdentifierReferenced(local)) {\n                      ++count\n                      p.remove()\n                    }\n                  })\n\n                  if (\n                    beforeCount !== count &&\n                    pattern.get('properties').length < 1\n                  ) {\n                    variablePath.remove()\n                  }\n                } else if (variablePath.node.id.type === 'ArrayPattern') {\n                  const pattern = variablePath.get('id') as NodePath<\n                    BabelTypes.ArrayPattern\n                  >\n\n                  const beforeCount = count\n                  const elements = pattern.get('elements')\n                  elements.forEach((e) => {\n                    let local: NodePath<BabelTypes.Identifier>\n                    if (e.node?.type === 'Identifier') {\n                      local = e as NodePath<BabelTypes.Identifier>\n                    } else if (e.node?.type === 'RestElement') {\n                      local = e.get('argument') as NodePath<\n                        BabelTypes.Identifier\n                      >\n                    } else {\n                      return\n                    }\n\n                    if (refs.has(local) && !isIdentifierReferenced(local)) {\n                      ++count\n                      e.remove()\n                    }\n                  })\n\n                  if (\n                    beforeCount !== count &&\n                    pattern.get('elements').length < 1\n                  ) {\n                    variablePath.remove()\n                  }\n                }\n              },\n              FunctionDeclaration: sweepFunction,\n              FunctionExpression: sweepFunction,\n              ArrowFunctionExpression: sweepFunction,\n              ImportSpecifier: sweepImport,\n              ImportDefaultSpecifier: sweepImport,\n              ImportNamespaceSpecifier: sweepImport,\n            })\n          } while (count)\n\n          decorateSsgExport(t, path, state)\n        },\n      },\n    },\n  }\n}\n"]}