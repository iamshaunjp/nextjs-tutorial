{"version":3,"sources":["../../../../build/webpack/plugins/jsconfig-paths-plugin.ts"],"names":["log","asterisk","hasZeroOrOneAsteriskCharacter","str","seenAsterisk","i","length","charCodeAt","pathIsRelative","testPath","test","tryParsePattern","pattern","indexOfStar","indexOf","undefined","prefix","substr","suffix","isPatternMatch","candidate","startsWith","endsWith","findBestPatternMatch","values","getPattern","matchedValue","longestMatchPrefixLength","v","matchPatternOrExact","patternStrings","patterns","patternString","push","_","isString","text","matchedText","substring","patternText","NODE_MODULES_REGEX","JsConfigPathsPlugin","constructor","paths","resolvedBaseUrl","apply","resolver","pathsKeys","Object","keys","baseDirectory","target","ensureHook","getHook","tapPromise","request","resolveContext","moduleName","path","match","posix","isAbsolute","process","platform","win32","matchedPattern","matchedStar","matchedPatternText","triedPaths","subst","curPath","replace","join","err","result","Promise","resolve","obj","assign","doResolve","resolverErr","resolverResult"],"mappings":"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","sourcesContent":["/**\n * This webpack resolver is largely based on TypeScript's \"paths\" handling\n * The TypeScript license can be found here:\n * https://github.com/microsoft/TypeScript/blob/214df64e287804577afa1fea0184c18c40f7d1ca/LICENSE.txt\n */\nimport path from 'path'\nimport { webpack } from 'next/dist/compiled/webpack/webpack'\nimport { debug } from 'next/dist/compiled/debug'\n\nconst log = debug('next:jsconfig-paths-plugin')\n\nexport interface Pattern {\n  prefix: string\n  suffix: string\n}\n\nconst asterisk = 0x2a\n\nexport function hasZeroOrOneAsteriskCharacter(str: string): boolean {\n  let seenAsterisk = false\n  for (let i = 0; i < str.length; i++) {\n    if (str.charCodeAt(i) === asterisk) {\n      if (!seenAsterisk) {\n        seenAsterisk = true\n      } else {\n        // have already seen asterisk\n        return false\n      }\n    }\n  }\n  return true\n}\n\n/**\n * Determines whether a path starts with a relative path component (i.e. `.` or `..`).\n */\nexport function pathIsRelative(testPath: string): boolean {\n  return /^\\.\\.?($|[\\\\/])/.test(testPath)\n}\n\nexport function tryParsePattern(pattern: string): Pattern | undefined {\n  // This should be verified outside of here and a proper error thrown.\n  const indexOfStar = pattern.indexOf('*')\n  return indexOfStar === -1\n    ? undefined\n    : {\n        prefix: pattern.substr(0, indexOfStar),\n        suffix: pattern.substr(indexOfStar + 1),\n      }\n}\n\nfunction isPatternMatch({ prefix, suffix }: Pattern, candidate: string) {\n  return (\n    candidate.length >= prefix.length + suffix.length &&\n    candidate.startsWith(prefix) &&\n    candidate.endsWith(suffix)\n  )\n}\n\n/** Return the object corresponding to the best pattern to match `candidate`. */\nexport function findBestPatternMatch<T>(\n  values: readonly T[],\n  getPattern: (value: T) => Pattern,\n  candidate: string\n): T | undefined {\n  let matchedValue: T | undefined\n  // use length of prefix as betterness criteria\n  let longestMatchPrefixLength = -1\n\n  for (const v of values) {\n    const pattern = getPattern(v)\n    if (\n      isPatternMatch(pattern, candidate) &&\n      pattern.prefix.length > longestMatchPrefixLength\n    ) {\n      longestMatchPrefixLength = pattern.prefix.length\n      matchedValue = v\n    }\n  }\n\n  return matchedValue\n}\n\n/**\n * patternStrings contains both pattern strings (containing \"*\") and regular strings.\n * Return an exact match if possible, or a pattern match, or undefined.\n * (These are verified by verifyCompilerOptions to have 0 or 1 \"*\" characters.)\n */\nexport function matchPatternOrExact(\n  patternStrings: readonly string[],\n  candidate: string\n): string | Pattern | undefined {\n  const patterns: Pattern[] = []\n  for (const patternString of patternStrings) {\n    if (!hasZeroOrOneAsteriskCharacter(patternString)) continue\n    const pattern = tryParsePattern(patternString)\n    if (pattern) {\n      patterns.push(pattern)\n    } else if (patternString === candidate) {\n      // pattern was matched as is - no need to search further\n      return patternString\n    }\n  }\n\n  return findBestPatternMatch(patterns, (_) => _, candidate)\n}\n\n/**\n * Tests whether a value is string\n */\nexport function isString(text: unknown): text is string {\n  return typeof text === 'string'\n}\n\n/**\n * Given that candidate matches pattern, returns the text matching the '*'.\n * E.g.: matchedText(tryParsePattern(\"foo*baz\"), \"foobarbaz\") === \"bar\"\n */\nexport function matchedText(pattern: Pattern, candidate: string): string {\n  return candidate.substring(\n    pattern.prefix.length,\n    candidate.length - pattern.suffix.length\n  )\n}\n\nexport function patternText({ prefix, suffix }: Pattern): string {\n  return `${prefix}*${suffix}`\n}\n\nconst NODE_MODULES_REGEX = /node_modules/\n\ntype Paths = { [match: string]: string[] }\n\n/**\n * Handles tsconfig.json or jsconfig.js \"paths\" option for webpack\n * Largely based on how the TypeScript compiler handles it:\n * https://github.com/microsoft/TypeScript/blob/1a9c8197fffe3dace5f8dca6633d450a88cba66d/src/compiler/moduleNameResolver.ts#L1362\n */\nexport class JsConfigPathsPlugin implements webpack.ResolvePlugin {\n  paths: Paths\n  resolvedBaseUrl: string\n  constructor(paths: Paths, resolvedBaseUrl: string) {\n    this.paths = paths\n    this.resolvedBaseUrl = resolvedBaseUrl\n    log('tsconfig.json or jsconfig.json paths: %O', paths)\n    log('resolved baseUrl: %s', resolvedBaseUrl)\n  }\n  apply(resolver: any) {\n    const paths = this.paths\n    const pathsKeys = Object.keys(paths)\n\n    // If no aliases are added bail out\n    if (pathsKeys.length === 0) {\n      log('paths are empty, bailing out')\n      return\n    }\n\n    const baseDirectory = this.resolvedBaseUrl\n    const target = resolver.ensureHook('resolve')\n    resolver\n      .getHook('described-resolve')\n      .tapPromise(\n        'JsConfigPathsPlugin',\n        async (request: any, resolveContext: any) => {\n          const moduleName = request.request\n\n          // Exclude node_modules from paths support (speeds up resolving)\n          if (request.path.match(NODE_MODULES_REGEX)) {\n            log('skipping request as it is inside node_modules %s', moduleName)\n            return\n          }\n\n          if (\n            path.posix.isAbsolute(moduleName) ||\n            (process.platform === 'win32' && path.win32.isAbsolute(moduleName))\n          ) {\n            log('skipping request as it is an absolute path %s', moduleName)\n            return\n          }\n\n          if (pathIsRelative(moduleName)) {\n            log('skipping request as it is a relative path %s', moduleName)\n            return\n          }\n\n          // log('starting to resolve request %s', moduleName)\n\n          // If the module name does not match any of the patterns in `paths` we hand off resolving to webpack\n          const matchedPattern = matchPatternOrExact(pathsKeys, moduleName)\n          if (!matchedPattern) {\n            log('moduleName did not match any paths pattern %s', moduleName)\n            return\n          }\n\n          const matchedStar = isString(matchedPattern)\n            ? undefined\n            : matchedText(matchedPattern, moduleName)\n          const matchedPatternText = isString(matchedPattern)\n            ? matchedPattern\n            : patternText(matchedPattern)\n\n          let triedPaths = []\n\n          for (const subst of paths[matchedPatternText]) {\n            const curPath = matchedStar\n              ? subst.replace('*', matchedStar)\n              : subst\n\n            // Ensure .d.ts is not matched\n            if (curPath.endsWith('.d.ts')) {\n              continue\n            }\n\n            const candidate = path.join(baseDirectory, curPath)\n            const [err, result] = await new Promise((resolve) => {\n              const obj = Object.assign({}, request, {\n                request: candidate,\n              })\n              resolver.doResolve(\n                target,\n                obj,\n                `Aliased with tsconfig.json or jsconfig.json ${matchedPatternText} to ${candidate}`,\n                resolveContext,\n                (resolverErr: any, resolverResult: any | undefined) => {\n                  resolve([resolverErr, resolverResult])\n                }\n              )\n            })\n\n            // There's multiple paths values possible, so we first have to iterate them all first before throwing an error\n            if (err || result === undefined) {\n              triedPaths.push(candidate)\n              continue\n            }\n\n            return result\n          }\n        }\n      )\n  }\n}\n"]}