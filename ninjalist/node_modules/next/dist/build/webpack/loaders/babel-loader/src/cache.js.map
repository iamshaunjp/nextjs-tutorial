{"version":3,"sources":["../../../../../../build/webpack/loaders/babel-loader/src/cache.js"],"names":["read","cacheDirectory","etag","cachedResult","tracer","startSpan","cacache","get","JSON","parse","data","write","put","stringify","source","identifier","options","hash","contents","update","digest","handleCache","params","span","cacheIdentifier","file","res","setAttribute","err","result"],"mappings":"iEAAA,8BACA,0CACA,8DACA,2E,mFAEA,cAAeA,CAAAA,IAAf,CAAoBC,cAApB,CAAoCC,IAApC,CAA0C,CACxC,KAAMC,CAAAA,YAAY,CAAG,KAAM,yBACzBC,eAAOC,SAAP,CAAiB,iBAAjB,CADyB,CAEzB,SAAY,KAAMC,kBAAQC,GAAR,CAAYN,cAAZ,CAA4BC,IAA5B,CAFO,CAA3B,CAKA,MAAOM,CAAAA,IAAI,CAACC,KAAL,CAAWN,YAAY,CAACO,IAAxB,CAAP,CACD,CAED,QAASC,CAAAA,KAAT,CAAeV,cAAf,CAA+BC,IAA/B,CAAqCQ,IAArC,CAA2C,CACzC,MAAOJ,kBAAQM,GAAR,CAAYX,cAAZ,CAA4BC,IAA5B,CAAkCM,IAAI,CAACK,SAAL,CAAeH,IAAf,CAAlC,CAAP,CACD,CAED,KAAMR,CAAAA,IAAI,CAAG,SAAUY,MAAV,CAAkBC,UAAlB,CAA8BC,OAA9B,CAAuC,CAClD,KAAMC,CAAAA,IAAI,CAAG,uBAAW,KAAX,CAAb,CAEA,KAAMC,CAAAA,QAAQ,CAAGV,IAAI,CAACK,SAAL,CAAe,CAAEC,MAAF,CAAUE,OAAV,CAAmBD,UAAnB,CAAf,CAAjB,CAEAE,IAAI,CAACE,MAAL,CAAYD,QAAZ,EAEA,MAAOD,CAAAA,IAAI,CAACG,MAAL,CAAY,KAAZ,CAAP,CACD,CARD,CAUe,cAAeC,CAAAA,WAAf,CAA2BC,MAA3B,CAAmC,CAChD,KAAMC,CAAAA,IAAI,CAAGnB,eAAOC,SAAP,CAAiB,cAAjB,CAAb,CACA,MAAO,yBAAakB,IAAb,CAAmB,SAAY,CACpC,KAAM,CAAET,MAAF,CAAUE,OAAO,CAAG,EAApB,CAAwBQ,eAAxB,CAAyCvB,cAAzC,EAA4DqB,MAAlE,CAEA,KAAMG,CAAAA,IAAI,CAAGvB,IAAI,CAACY,MAAD,CAASU,eAAT,CAAjB,CAEA,GAAI,CACF;AACA;AACA,KAAME,CAAAA,GAAG,CAAG,KAAM1B,CAAAA,IAAI,CAACC,cAAD,CAAiBwB,IAAjB,CAAtB,CACAF,IAAI,CAACI,YAAL,CAAkB,OAAlB,CAA2BD,GAAG,CAAG,KAAH,CAAW,MAAzC,EACA,MAAOA,CAAAA,GAAP,CACD,CAAC,MAAOE,GAAP,CAAY,CAAE,CAEhB;AACA;AACA,KAAMC,CAAAA,MAAM,CAAG,KAAM,yBACnBzB,eAAOC,SAAP,CAAiB,WAAjB,CADmB,CAEnB,SAAY,CACV,MAAO,uBAAUS,MAAV,CAAkBE,OAAlB,CAAP,CACD,CAJkB,CAArB,CAOA,KAAML,CAAAA,KAAK,CAACV,cAAD,CAAiBwB,IAAjB,CAAuBI,MAAvB,CAAX,CAEA,MAAOA,CAAAA,MAAP,CACD,CAzBM,CAAP,CA0BD","sourcesContent":["import { createHash } from 'crypto'\nimport { tracer, traceAsyncFn } from '../../../../tracer'\nimport transform from './transform'\nimport cacache from 'next/dist/compiled/cacache'\n\nasync function read(cacheDirectory, etag) {\n  const cachedResult = await traceAsyncFn(\n    tracer.startSpan('read-cache-file'),\n    async () => await cacache.get(cacheDirectory, etag)\n  )\n\n  return JSON.parse(cachedResult.data)\n}\n\nfunction write(cacheDirectory, etag, data) {\n  return cacache.put(cacheDirectory, etag, JSON.stringify(data))\n}\n\nconst etag = function (source, identifier, options) {\n  const hash = createHash('md4')\n\n  const contents = JSON.stringify({ source, options, identifier })\n\n  hash.update(contents)\n\n  return hash.digest('hex')\n}\n\nexport default async function handleCache(params) {\n  const span = tracer.startSpan('handle-cache')\n  return traceAsyncFn(span, async () => {\n    const { source, options = {}, cacheIdentifier, cacheDirectory } = params\n\n    const file = etag(source, cacheIdentifier)\n\n    try {\n      // No errors mean that the file was previously cached\n      // we just need to return it\n      const res = await read(cacheDirectory, file)\n      span.setAttribute('cache', res ? 'HIT' : 'MISS')\n      return res\n    } catch (err) {}\n\n    // Otherwise just transform the file\n    // return it to the user asap and write it in cache\n    const result = await traceAsyncFn(\n      tracer.startSpan('transform'),\n      async () => {\n        return transform(source, options)\n      }\n    )\n\n    await write(cacheDirectory, file, result)\n\n    return result\n  })\n}\n"]}