{"version":3,"sources":["../../../../../build/webpack/loaders/next-serverless-loader/api-handler.ts"],"names":["getApiHandler","ctx","pageModule","encodedPreviewProps","pageIsDynamic","experimental","initServer","onError","handleRewrites","handleBasePath","dynamicRouteMatcher","normalizeDynamicRouteParams","req","res","trustQuery","headers","vercelHeader","parsedUrl","url","query","nextInternalLocale","params","result","pathname","Object","assign","err","console","error","code","statusCode","end"],"mappings":"yEAAA,wBAEA,kEACA,8BAEO,QAASA,CAAAA,aAAT,CAAuBC,GAAvB,CAAkD,CACvD,KAAM,CACJC,UADI,CAEJC,mBAFI,CAGJC,aAHI,CAIJC,YAAY,CAAE,CAAEC,UAAF,CAAcC,OAAd,CAJV,EAKFN,GALJ,CAMA,KAAM,CACJO,cADI,CAEJC,cAFI,CAGJC,mBAHI,CAIJC,2BAJI,EAKF,oBAASV,GAAT,CALJ,CAOA,MAAO,OAAOW,GAAP,CAA6BC,GAA7B,GAAqD,CAC1D,GAAI,CACF,KAAMP,CAAAA,UAAU,EAAhB,CAEA;AACA;AACA,KAAMQ,CAAAA,UAAU,CAAGF,GAAG,CAACG,OAAJ,CAAYC,mBAAZ,CAAnB,CACA,KAAMC,CAAAA,SAAS,CAAGT,cAAc,CAAC,eAASI,GAAG,CAACM,GAAb,CAAmB,IAAnB,CAAD,CAAhC,CAEA,GAAID,SAAS,CAACE,KAAV,CAAgBC,kBAApB,CAAwC,CACtC,MAAOH,CAAAA,SAAS,CAACE,KAAV,CAAgBC,kBAAvB,CACD,CACDX,cAAc,CAACG,GAAD,CAAMK,SAAN,CAAd,CAEA,GAAII,CAAAA,MAAM,CAAG,EAAb,CAEA,GAAIjB,aAAJ,CAAmB,CACjB,KAAMkB,CAAAA,MAAM,CAAGX,2BAA2B,CACxCG,UAAU,CACNG,SAAS,CAACE,KADJ,CAELT,mBAAmB,CAAEO,SAAS,CAACM,QAAZ,CAHgB,CAA1C,CASAF,MAAM,CAAGC,MAAM,CAACD,MAAhB,CACD,CAED,KAAM,0BACJT,GADI,CAEJC,GAFI,CAGJW,MAAM,CAACC,MAAP,CAAc,EAAd,CAAkBR,SAAS,CAACE,KAA5B,CAAmCE,MAAnC,CAHI,CAIJ,KAAMnB,CAAAA,UAJF,CAKJC,mBALI,CAMJ,IANI,CAOJI,OAPI,CAAN,CASD,CAAC,MAAOmB,GAAP,CAAY,CACZC,OAAO,CAACC,KAAR,CAAcF,GAAd,EACA,KAAMnB,CAAAA,OAAO,CAACmB,GAAD,CAAb,CAEA;AACA,GAAIA,GAAG,CAACG,IAAJ,GAAa,eAAjB,CAAkC,CAChChB,GAAG,CAACiB,UAAJ,CAAiB,GAAjB,CACAjB,GAAG,CAACkB,GAAJ,CAAQ,aAAR,EACD,CAHD,IAGO,CACL;AACA,KAAML,CAAAA,GAAN,CACD,CACF,CACF,CAnDD,CAoDD","sourcesContent":["import { parse as parseUrl } from 'url'\nimport { IncomingMessage, ServerResponse } from 'http'\nimport { apiResolver } from '../../../../next-server/server/api-utils'\nimport { getUtils, vercelHeader, ServerlessHandlerCtx } from './utils'\n\nexport function getApiHandler(ctx: ServerlessHandlerCtx) {\n  const {\n    pageModule,\n    encodedPreviewProps,\n    pageIsDynamic,\n    experimental: { initServer, onError },\n  } = ctx\n  const {\n    handleRewrites,\n    handleBasePath,\n    dynamicRouteMatcher,\n    normalizeDynamicRouteParams,\n  } = getUtils(ctx)\n\n  return async (req: IncomingMessage, res: ServerResponse) => {\n    try {\n      await initServer()\n\n      // We need to trust the dynamic route params from the proxy\n      // to ensure we are using the correct values\n      const trustQuery = req.headers[vercelHeader]\n      const parsedUrl = handleRewrites(parseUrl(req.url!, true))\n\n      if (parsedUrl.query.nextInternalLocale) {\n        delete parsedUrl.query.nextInternalLocale\n      }\n      handleBasePath(req, parsedUrl)\n\n      let params = {}\n\n      if (pageIsDynamic) {\n        const result = normalizeDynamicRouteParams(\n          trustQuery\n            ? parsedUrl.query\n            : (dynamicRouteMatcher!(parsedUrl.pathname) as Record<\n                string,\n                string | string[]\n              >)\n        )\n\n        params = result.params\n      }\n\n      await apiResolver(\n        req,\n        res,\n        Object.assign({}, parsedUrl.query, params),\n        await pageModule,\n        encodedPreviewProps,\n        true,\n        onError\n      )\n    } catch (err) {\n      console.error(err)\n      await onError(err)\n\n      // TODO: better error for DECODE_FAILED?\n      if (err.code === 'DECODE_FAILED') {\n        res.statusCode = 400\n        res.end('Bad Request')\n      } else {\n        // Throw the error to crash the serverless function\n        throw err\n      }\n    }\n  }\n}\n"]}