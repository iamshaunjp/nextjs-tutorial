{"version":3,"sources":["../../build/tracer.ts"],"names":["tracer","api","trace","getTracer","process","env","__NEXT_VERSION","compilerStacks","WeakMap","compilerStoppedSpans","stackPush","compiler","spanName","attrs","stack","get","span","set","startSpan","undefined","parent","length","withSpan","push","stackPop","associatedName","console","warn","stoppedSpans","Set","has","poppedSpan","pop","add","end","indexOf","traceFn","fn","traceAsyncFn"],"mappings":"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","sourcesContent":["import api, { Span } from '@opentelemetry/api'\n\nexport const tracer = api.trace.getTracer('next', process.env.__NEXT_VERSION)\n\nconst compilerStacks = new WeakMap()\nconst compilerStoppedSpans = new WeakMap()\n\nexport function stackPush(compiler: any, spanName: string, attrs?: any): any {\n  let stack = compilerStacks.get(compiler)\n  let span\n\n  if (!stack) {\n    compilerStacks.set(compiler, (stack = []))\n    span = tracer.startSpan(spanName, attrs ? attrs() : undefined)\n  } else {\n    const parent = stack[stack.length - 1]\n    if (parent) {\n      tracer.withSpan(parent, () => {\n        span = tracer.startSpan(spanName, attrs ? attrs() : undefined)\n      })\n    } else {\n      span = tracer.startSpan(spanName, attrs ? attrs() : undefined)\n    }\n  }\n\n  stack.push(span)\n  return span\n}\n\nexport function stackPop(compiler: any, span: any, associatedName?: string) {\n  let stack = compilerStacks.get(compiler)\n  if (!stack) {\n    console.warn(\n      'Attempted to pop from non-existent stack. Compiler reference must be bad.'\n    )\n    return\n  }\n\n  let stoppedSpans: Set<Span> = compilerStoppedSpans.get(compiler)\n  if (!stoppedSpans) {\n    stoppedSpans = new Set()\n    compilerStoppedSpans.set(compiler, stoppedSpans)\n  }\n  if (stoppedSpans.has(span)) {\n    console.warn(\n      `Attempted to terminate tracing span that was already stopped for ${associatedName}`\n    )\n    return\n  }\n\n  while (true) {\n    let poppedSpan = stack.pop()\n\n    if (poppedSpan === span) {\n      stoppedSpans.add(poppedSpan)\n      span.end()\n      stoppedSpans.add(span)\n      break\n    } else if (poppedSpan === undefined || stack.indexOf(span) === -1) {\n      // We've either reached the top of the stack or the stack doesn't contain\n      // the span for another reason.\n      console.warn(`Tracing span was not found in stack for: ${associatedName}`)\n      stoppedSpans.add(span)\n      span.end()\n      break\n    } else if (stack.indexOf(span) !== -1) {\n      console.warn(\n        `Attempted to pop span that was not at top of stack for: ${associatedName}`\n      )\n      stoppedSpans.add(poppedSpan)\n      poppedSpan.end()\n    }\n  }\n}\n\nexport function traceFn<T extends (...args: unknown[]) => ReturnType<T>>(\n  span: Span,\n  fn: T\n): ReturnType<T> {\n  return tracer.withSpan(span, () => {\n    try {\n      return fn()\n    } finally {\n      span.end()\n    }\n  })\n}\n\nexport function traceAsyncFn<T extends (...args: unknown[]) => ReturnType<T>>(\n  span: Span,\n  fn: T\n): Promise<ReturnType<T>> {\n  return tracer.withSpan(span, async () => {\n    try {\n      return await fn()\n    } finally {\n      span.end()\n    }\n  })\n}\n"]}