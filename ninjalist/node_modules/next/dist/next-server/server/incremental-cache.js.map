{"version":3,"sources":["../../../next-server/server/incremental-cache.ts"],"names":["toRoute","pathname","replace","IncrementalCache","constructor","max","dev","distDir","pagesDir","flushToDisk","locales","incrementalOptions","prerenderManifest","cache","version","routes","dynamicRoutes","notFoundRoutes","preview","JSON","parse","path","join","PRERENDER_MANIFEST","LRUCache","length","val","isNotFound","isRedirect","html","stringify","pageData","getSeedPath","ext","calculateRevalidate","curTime","Date","getTime","initialRevalidateSeconds","revalidateAfter","getFallback","page","promises","readFile","get","data","includes","set","_","isStale","manifestPath","manifestEntry","curRevalidate","revalidateSeconds","dataRoute","posix","srcRoute","seedPath","mkdir","dirname","recursive","writeFile","error","console","warn"],"mappings":"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","sourcesContent":["import { promises, readFileSync } from 'fs'\nimport LRUCache from 'next/dist/compiled/lru-cache'\nimport path from 'path'\nimport { PrerenderManifest } from '../../build'\nimport { PRERENDER_MANIFEST } from '../lib/constants'\nimport { normalizePagePath } from './normalize-page-path'\n\nfunction toRoute(pathname: string): string {\n  return pathname.replace(/\\/$/, '').replace(/\\/index$/, '') || '/'\n}\n\ntype IncrementalCacheValue = {\n  html?: string\n  pageData?: any\n  isStale?: boolean\n  isNotFound?: boolean\n  isRedirect?: boolean\n  curRevalidate?: number | false\n  // milliseconds to revalidate after\n  revalidateAfter: number | false\n}\n\nexport class IncrementalCache {\n  incrementalOptions: {\n    flushToDisk?: boolean\n    pagesDir?: string\n    distDir?: string\n    dev?: boolean\n  }\n\n  prerenderManifest: PrerenderManifest\n  cache: LRUCache<string, IncrementalCacheValue>\n  locales?: string[]\n\n  constructor({\n    max,\n    dev,\n    distDir,\n    pagesDir,\n    flushToDisk,\n    locales,\n  }: {\n    dev: boolean\n    max?: number\n    distDir: string\n    pagesDir: string\n    flushToDisk?: boolean\n    locales?: string[]\n  }) {\n    this.incrementalOptions = {\n      dev,\n      distDir,\n      pagesDir,\n      flushToDisk:\n        !dev && (typeof flushToDisk !== 'undefined' ? flushToDisk : true),\n    }\n    this.locales = locales\n\n    if (dev) {\n      this.prerenderManifest = {\n        version: -1 as any, // letting us know this doesn't conform to spec\n        routes: {},\n        dynamicRoutes: {},\n        notFoundRoutes: [],\n        preview: null as any, // `preview` is special case read in next-dev-server\n      }\n    } else {\n      this.prerenderManifest = JSON.parse(\n        readFileSync(path.join(distDir, PRERENDER_MANIFEST), 'utf8')\n      )\n    }\n\n    this.cache = new LRUCache({\n      // default to 50MB limit\n      max: max || 50 * 1024 * 1024,\n      length(val) {\n        if (val.isNotFound || val.isRedirect) return 25\n        // rough estimate of size of cache value\n        return val.html!.length + JSON.stringify(val.pageData).length\n      },\n    })\n  }\n\n  private getSeedPath(pathname: string, ext: string): string {\n    return path.join(this.incrementalOptions.pagesDir!, `${pathname}.${ext}`)\n  }\n\n  private calculateRevalidate(pathname: string): number | false {\n    pathname = toRoute(pathname)\n\n    // in development we don't have a prerender-manifest\n    // and default to always revalidating to allow easier debugging\n    const curTime = new Date().getTime()\n    if (this.incrementalOptions.dev) return curTime - 1000\n\n    const { initialRevalidateSeconds } = this.prerenderManifest.routes[\n      pathname\n    ] || {\n      initialRevalidateSeconds: 1,\n    }\n    const revalidateAfter =\n      typeof initialRevalidateSeconds === 'number'\n        ? initialRevalidateSeconds * 1000 + curTime\n        : initialRevalidateSeconds\n\n    return revalidateAfter\n  }\n\n  getFallback(page: string): Promise<string> {\n    page = normalizePagePath(page)\n    return promises.readFile(this.getSeedPath(page, 'html'), 'utf8')\n  }\n\n  // get data from cache if available\n  async get(pathname: string): Promise<IncrementalCacheValue | void> {\n    if (this.incrementalOptions.dev) return\n    pathname = normalizePagePath(pathname)\n\n    let data = this.cache.get(pathname)\n\n    // let's check the disk for seed data\n    if (!data) {\n      if (this.prerenderManifest.notFoundRoutes.includes(pathname)) {\n        return { isNotFound: true, revalidateAfter: false }\n      }\n\n      try {\n        const html = await promises.readFile(\n          this.getSeedPath(pathname, 'html'),\n          'utf8'\n        )\n        const pageData = JSON.parse(\n          await promises.readFile(this.getSeedPath(pathname, 'json'), 'utf8')\n        )\n\n        data = {\n          html,\n          pageData,\n          revalidateAfter: this.calculateRevalidate(pathname),\n        }\n        this.cache.set(pathname, data)\n      } catch (_) {\n        // unable to get data from disk\n      }\n    }\n\n    if (\n      data &&\n      data.revalidateAfter !== false &&\n      data.revalidateAfter < new Date().getTime()\n    ) {\n      data.isStale = true\n    }\n\n    const manifestPath = toRoute(pathname)\n    const manifestEntry = this.prerenderManifest.routes[manifestPath]\n\n    if (data && manifestEntry) {\n      data.curRevalidate = manifestEntry.initialRevalidateSeconds\n    }\n    return data\n  }\n\n  // populate the incremental cache with new data\n  async set(\n    pathname: string,\n    data: {\n      html?: string\n      pageData?: any\n      isNotFound?: boolean\n      isRedirect?: boolean\n    },\n    revalidateSeconds?: number | false\n  ) {\n    if (this.incrementalOptions.dev) return\n    if (typeof revalidateSeconds !== 'undefined') {\n      // TODO: Update this to not mutate the manifest from the\n      // build.\n      this.prerenderManifest.routes[pathname] = {\n        dataRoute: path.posix.join(\n          '/_next/data',\n          `${normalizePagePath(pathname)}.json`\n        ),\n        srcRoute: null, // FIXME: provide actual source route, however, when dynamically appending it doesn't really matter\n        initialRevalidateSeconds: revalidateSeconds,\n      }\n    }\n\n    pathname = normalizePagePath(pathname)\n    this.cache.set(pathname, {\n      ...data,\n      revalidateAfter: this.calculateRevalidate(pathname),\n    })\n\n    // TODO: This option needs to cease to exist unless it stops mutating the\n    // `next build` output's manifest.\n    if (this.incrementalOptions.flushToDisk && !data.isNotFound) {\n      try {\n        const seedPath = this.getSeedPath(pathname, 'html')\n        await promises.mkdir(path.dirname(seedPath), { recursive: true })\n        await promises.writeFile(seedPath, data.html, 'utf8')\n        await promises.writeFile(\n          this.getSeedPath(pathname, 'json'),\n          JSON.stringify(data.pageData),\n          'utf8'\n        )\n      } catch (error) {\n        // failed to flush to disk\n        console.warn('Failed to update prerender files for', pathname, error)\n      }\n    }\n  }\n}\n"]}