{"version":3,"sources":["../../../next-server/server/font-utils.ts"],"names":["https","require","CHROME_UA","IE_UA","getFontForUA","url","UA","Promise","resolve","rawData","get","headers","res","on","chunk","toString","getFontDefinitionFromNetwork","result","getFontDefinitionFromManifest","manifest","find","font","content"],"mappings":"2KAAA,KAAMA,CAAAA,KAAK,CAAGC,OAAO,CAAC,OAAD,CAArB,CAEA,KAAMC,CAAAA,SAAS,CACb,0HADF,CAEA,KAAMC,CAAAA,KAAK,CAAG,gEAAd,CAOA,QAASC,CAAAA,YAAT,CAAsBC,GAAtB,CAAmCC,EAAnC,CAAgE,CAC9D,MAAO,IAAIC,CAAAA,OAAJ,CAAaC,OAAD,EAAa,CAC9B,GAAIC,CAAAA,OAAY,CAAG,EAAnB,CACAT,KAAK,CAACU,GAAN,CACEL,GADF,CAEE,CACEM,OAAO,CAAE,CACP,aAAcL,EADP,CADX,CAFF,CAOGM,GAAD,EAAc,CACZA,GAAG,CAACC,EAAJ,CAAO,MAAP,CAAgBC,KAAD,EAAgB,CAC7BL,OAAO,EAAIK,KAAX,CACD,CAFD,EAGAF,GAAG,CAACC,EAAJ,CAAO,KAAP,CAAc,IAAM,CAClBL,OAAO,CAACC,OAAO,CAACM,QAAR,CAAiB,MAAjB,CAAD,CAAP,CACD,CAFD,EAGD,CAdH,EAgBD,CAlBM,CAAP,CAmBD,CAEM,cAAeC,CAAAA,4BAAf,CACLX,GADK,CAEY,CACjB,GAAIY,CAAAA,MAAM,CAAG,EAAb,CACA;AACF;AACA;AACA,KACEA,MAAM,EAAI,KAAMb,CAAAA,YAAY,CAACC,GAAD,CAAMF,KAAN,CAA5B,CACAc,MAAM,EAAI,KAAMb,CAAAA,YAAY,CAACC,GAAD,CAAMH,SAAN,CAA5B,CACA,MAAOe,CAAAA,MAAP,CACD,CAEM,QAASC,CAAAA,6BAAT,CACLb,GADK,CAELc,QAFK,CAGG,oBACR,MACE,iBAAAA,QAAQ,CAACC,IAAT,CAAeC,IAAD,EAAU,CACtB,GAAIA,IAAI,EAAIA,IAAI,CAAChB,GAAL,GAAaA,GAAzB,CAA8B,CAC5B,MAAO,KAAP,CACD,CACD,MAAO,MAAP,CACD,CALD,+BAKIiB,OALJ,GAKe,EANjB,CAQD","sourcesContent":["const https = require('https')\n\nconst CHROME_UA =\n  'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_5) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.61 Safari/537.36'\nconst IE_UA = 'Mozilla/5.0 (Windows NT 10.0; Trident/7.0; rv:11.0) like Gecko'\n\nexport type FontManifest = Array<{\n  url: string\n  content: string\n}>\n\nfunction getFontForUA(url: string, UA: string): Promise<String> {\n  return new Promise((resolve) => {\n    let rawData: any = ''\n    https.get(\n      url,\n      {\n        headers: {\n          'user-agent': UA,\n        },\n      },\n      (res: any) => {\n        res.on('data', (chunk: any) => {\n          rawData += chunk\n        })\n        res.on('end', () => {\n          resolve(rawData.toString('utf8'))\n        })\n      }\n    )\n  })\n}\n\nexport async function getFontDefinitionFromNetwork(\n  url: string\n): Promise<string> {\n  let result = ''\n  /**\n   * The order of IE -> Chrome is important, other wise chrome starts loading woff1.\n   * CSS cascading 🤷‍♂️.\n   */\n  result += await getFontForUA(url, IE_UA)\n  result += await getFontForUA(url, CHROME_UA)\n  return result\n}\n\nexport function getFontDefinitionFromManifest(\n  url: string,\n  manifest: FontManifest\n): string {\n  return (\n    manifest.find((font) => {\n      if (font && font.url === url) {\n        return true\n      }\n      return false\n    })?.content || ''\n  )\n}\n"]}