{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getRouteRegex = getRouteRegex; // this isn't importing the escape-string-regex module\n// to reduce bytes\n\nfunction escapeRegex(str) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&');\n}\n\nfunction parseParameter(param) {\n  const optional = param.startsWith('[') && param.endsWith(']');\n\n  if (optional) {\n    param = param.slice(1, -1);\n  }\n\n  const repeat = param.startsWith('...');\n\n  if (repeat) {\n    param = param.slice(3);\n  }\n\n  return {\n    key: param,\n    repeat,\n    optional\n  };\n}\n\nfunction getRouteRegex(normalizedRoute) {\n  const segments = (normalizedRoute.replace(/\\/$/, '') || '/').slice(1).split('/');\n  const groups = {};\n  let groupIndex = 1;\n  const parameterizedRoute = segments.map(segment => {\n    if (segment.startsWith('[') && segment.endsWith(']')) {\n      const {\n        key,\n        optional,\n        repeat\n      } = parseParameter(segment.slice(1, -1));\n      groups[key] = {\n        pos: groupIndex++,\n        repeat,\n        optional\n      };\n      return repeat ? optional ? '(?:/(.+?))?' : '/(.+?)' : '/([^/]+?)';\n    } else {\n      return `/${escapeRegex(segment)}`;\n    }\n  }).join(''); // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n\n  if (true) {\n    let routeKeyCharCode = 97;\n    let routeKeyCharLength = 1; // builds a minimal routeKey using only a-z and minimal number of characters\n\n    const getSafeRouteKey = () => {\n      let routeKey = '';\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode);\n        routeKeyCharCode++;\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++;\n          routeKeyCharCode = 97;\n        }\n      }\n\n      return routeKey;\n    };\n\n    const routeKeys = {};\n    let namedParameterizedRoute = segments.map(segment => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const {\n          key,\n          optional,\n          repeat\n        } = parseParameter(segment.slice(1, -1)); // replace any non-word characters since they can break\n        // the named regex\n\n        let cleanedKey = key.replace(/\\W/g, '');\n        let invalidKey = false; // check if the key is still invalid and fallback to using a known\n        // safe key\n\n        if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n          invalidKey = true;\n        }\n\n        if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n          invalidKey = true;\n        }\n\n        if (invalidKey) {\n          cleanedKey = getSafeRouteKey();\n        }\n\n        routeKeys[cleanedKey] = key;\n        return repeat ? optional ? `(?:/(?<${cleanedKey}>.+?))?` : `/(?<${cleanedKey}>.+?)` : `/(?<${cleanedKey}>[^/]+?)`;\n      } else {\n        return `/${escapeRegex(segment)}`;\n      }\n    }).join('');\n    return {\n      re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n      groups,\n      routeKeys,\n      namedRegex: `^${namedParameterizedRoute}(?:/)?$`\n    };\n  }\n\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/route-regex.ts"],"names":["str","optional","param","repeat","key","segments","normalizedRoute","groups","groupIndex","parameterizedRoute","segment","parseParameter","pos","escapeRegex","routeKeyCharCode","routeKeyCharLength","getSafeRouteKey","routeKey","i","String","routeKeys","namedParameterizedRoute","cleanedKey","invalidKey","isNaN","parseInt","re","namedRegex"],"mappings":";;;uCAMA;AACA;;AACA,SAAA,WAAA,CAAA,GAAA,EAAkC;AAChC,SAAOA,GAAG,CAAHA,OAAAA,CAAAA,sBAAAA,EAAP,MAAOA,CAAP;AAGF;;AAAA,SAAA,cAAA,CAAA,KAAA,EAAuC;AACrC,QAAMC,QAAQ,GAAGC,KAAK,CAALA,UAAAA,CAAAA,GAAAA,KAAyBA,KAAK,CAALA,QAAAA,CAA1C,GAA0CA,CAA1C;;AACA,MAAA,QAAA,EAAc;AACZA,IAAAA,KAAK,GAAGA,KAAK,CAALA,KAAAA,CAAAA,CAAAA,EAAe,CAAvBA,CAAQA,CAARA;AAEF;;AAAA,QAAMC,MAAM,GAAGD,KAAK,CAALA,UAAAA,CAAf,KAAeA,CAAf;;AACA,MAAA,MAAA,EAAY;AACVA,IAAAA,KAAK,GAAGA,KAAK,CAALA,KAAAA,CAARA,CAAQA,CAARA;AAEF;;AAAA,SAAO;AAAEE,IAAAA,GAAG,EAAL,KAAA;AAAA,IAAA,MAAA;AAAP,IAAA;AAAO,GAAP;AAGK;;AAAA,SAAA,aAAA,CAAA,eAAA,EAOL;AACA,QAAMC,QAAQ,GAAG,CAACC,eAAe,CAAfA,OAAAA,CAAAA,KAAAA,EAAAA,EAAAA,KAAD,GAAA,EAAA,KAAA,CAAA,CAAA,EAAA,KAAA,CAAjB,GAAiB,CAAjB;AAIA,QAAMC,MAAsC,GAA5C,EAAA;AACA,MAAIC,UAAU,GAAd,CAAA;AACA,QAAMC,kBAAkB,GAAGJ,QAAQ,CAARA,GAAAA,CACnBK,OAAD,IAAa;AAChB,QAAIA,OAAO,CAAPA,UAAAA,CAAAA,GAAAA,KAA2BA,OAAO,CAAPA,QAAAA,CAA/B,GAA+BA,CAA/B,EAAsD;AACpD,YAAM;AAAA,QAAA,GAAA;AAAA,QAAA,QAAA;AAAA,QAAA;AAAA,UAA4BC,cAAc,CAACD,OAAO,CAAPA,KAAAA,CAAAA,CAAAA,EAAiB,CAAlE,CAAiDA,CAAD,CAAhD;AACAH,MAAAA,MAAM,CAANA,GAAM,CAANA,GAAc;AAAEK,QAAAA,GAAG,EAAEJ,UAAP,EAAA;AAAA,QAAA,MAAA;AAAdD,QAAAA;AAAc,OAAdA;AACA,aAAOJ,MAAM,GAAIF,QAAQ,GAAA,aAAA,GAAZ,QAAA,GAAb,WAAA;AAHF,KAAA,MAIO;AACL,aAAQ,IAAGY,WAAW,CAAA,OAAA,CAAtB,EAAA;AAEH;AATwBR,GAAAA,EAAAA,IAAAA,CAA3B,EAA2BA,CAA3B,CAPA,CAmBA;AACA;;AACA,YAAmC;AACjC,QAAIS,gBAAgB,GAApB,EAAA;AACA,QAAIC,kBAAkB,GAAtB,CAAA,CAFiC,CAIjC;;AACA,UAAMC,eAAe,GAAG,MAAM;AAC5B,UAAIC,QAAQ,GAAZ,EAAA;;AAEA,WAAK,IAAIC,CAAC,GAAV,CAAA,EAAgBA,CAAC,GAAjB,kBAAA,EAAwCA,CAAxC,EAAA,EAA6C;AAC3CD,QAAAA,QAAQ,IAAIE,MAAM,CAANA,YAAAA,CAAZF,gBAAYE,CAAZF;AACAH,QAAAA,gBAAgB;;AAEhB,YAAIA,gBAAgB,GAApB,GAAA,EAA4B;AAC1BC,UAAAA,kBAAkB;AAClBD,UAAAA,gBAAgB,GAAhBA,EAAAA;AAEH;AACD;;AAAA,aAAA,QAAA;AAZF,KAAA;;AAeA,UAAMM,SAAsC,GAA5C,EAAA;AAEA,QAAIC,uBAAuB,GAAGhB,QAAQ,CAARA,GAAAA,CACtBK,OAAD,IAAa;AAChB,UAAIA,OAAO,CAAPA,UAAAA,CAAAA,GAAAA,KAA2BA,OAAO,CAAPA,QAAAA,CAA/B,GAA+BA,CAA/B,EAAsD;AACpD,cAAM;AAAA,UAAA,GAAA;AAAA,UAAA,QAAA;AAAA,UAAA;AAAA,YAA4BC,cAAc,CAACD,OAAO,CAAPA,KAAAA,CAAAA,CAAAA,EAAiB,CAAlE,CAAiDA,CAAD,CAAhD,CADoD,CAEpD;AACA;;AACA,YAAIY,UAAU,GAAGlB,GAAG,CAAHA,OAAAA,CAAAA,KAAAA,EAAjB,EAAiBA,CAAjB;AACA,YAAImB,UAAU,GAAd,KAAA,CALoD,CAOpD;AACA;;AACA,YAAID,UAAU,CAAVA,MAAAA,KAAAA,CAAAA,IAA2BA,UAAU,CAAVA,MAAAA,GAA/B,EAAA,EAAuD;AACrDC,UAAAA,UAAU,GAAVA,IAAAA;AAEF;;AAAA,YAAI,CAACC,KAAK,CAACC,QAAQ,CAACH,UAAU,CAAVA,MAAAA,CAAAA,CAAAA,EAApB,CAAoBA,CAAD,CAAT,CAAV,EAA+C;AAC7CC,UAAAA,UAAU,GAAVA,IAAAA;AAGF;;AAAA,YAAA,UAAA,EAAgB;AACdD,UAAAA,UAAU,GAAGN,eAAbM,EAAAA;AAGFF;;AAAAA,QAAAA,SAAS,CAATA,UAAS,CAATA,GAAAA,GAAAA;AACA,eAAOjB,MAAM,GACTF,QAAQ,GACL,UAASqB,UADJ,SAAA,GAEL,OAAMA,UAHA,OAAA,GAIR,OAAMA,UAJX,UAAA;AArBF,OAAA,MA0BO;AACL,eAAQ,IAAGT,WAAW,CAAA,OAAA,CAAtB,EAAA;AAEH;AA/B2BR,KAAAA,EAAAA,IAAAA,CAA9B,EAA8BA,CAA9B;AAkCA,WAAO;AACLqB,MAAAA,EAAE,EAAE,IAAA,MAAA,CAAY,IAAGjB,kBADd,SACD,CADC;AAAA,MAAA,MAAA;AAAA,MAAA,SAAA;AAILkB,MAAAA,UAAU,EAAG,IAAGN,uBAJlB;AAAO,KAAP;AAQF;;AAAA,SAAO;AACLK,IAAAA,EAAE,EAAE,IAAA,MAAA,CAAY,IAAGjB,kBADd,SACD,CADC;AAAP,IAAA;AAAO,GAAP;AAID","sourcesContent":["export interface Group {\n  pos: number\n  repeat: boolean\n  optional: boolean\n}\n\n// this isn't importing the escape-string-regex module\n// to reduce bytes\nfunction escapeRegex(str: string) {\n  return str.replace(/[|\\\\{}()[\\]^$+*?.-]/g, '\\\\$&')\n}\n\nfunction parseParameter(param: string) {\n  const optional = param.startsWith('[') && param.endsWith(']')\n  if (optional) {\n    param = param.slice(1, -1)\n  }\n  const repeat = param.startsWith('...')\n  if (repeat) {\n    param = param.slice(3)\n  }\n  return { key: param, repeat, optional }\n}\n\nexport function getRouteRegex(\n  normalizedRoute: string\n): {\n  re: RegExp\n  namedRegex?: string\n  routeKeys?: { [named: string]: string }\n  groups: { [groupName: string]: Group }\n} {\n  const segments = (normalizedRoute.replace(/\\/$/, '') || '/')\n    .slice(1)\n    .split('/')\n\n  const groups: { [groupName: string]: Group } = {}\n  let groupIndex = 1\n  const parameterizedRoute = segments\n    .map((segment) => {\n      if (segment.startsWith('[') && segment.endsWith(']')) {\n        const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n        groups[key] = { pos: groupIndex++, repeat, optional }\n        return repeat ? (optional ? '(?:/(.+?))?' : '/(.+?)') : '/([^/]+?)'\n      } else {\n        return `/${escapeRegex(segment)}`\n      }\n    })\n    .join('')\n\n  // dead code eliminate for browser since it's only needed\n  // while generating routes-manifest\n  if (typeof window === 'undefined') {\n    let routeKeyCharCode = 97\n    let routeKeyCharLength = 1\n\n    // builds a minimal routeKey using only a-z and minimal number of characters\n    const getSafeRouteKey = () => {\n      let routeKey = ''\n\n      for (let i = 0; i < routeKeyCharLength; i++) {\n        routeKey += String.fromCharCode(routeKeyCharCode)\n        routeKeyCharCode++\n\n        if (routeKeyCharCode > 122) {\n          routeKeyCharLength++\n          routeKeyCharCode = 97\n        }\n      }\n      return routeKey\n    }\n\n    const routeKeys: { [named: string]: string } = {}\n\n    let namedParameterizedRoute = segments\n      .map((segment) => {\n        if (segment.startsWith('[') && segment.endsWith(']')) {\n          const { key, optional, repeat } = parseParameter(segment.slice(1, -1))\n          // replace any non-word characters since they can break\n          // the named regex\n          let cleanedKey = key.replace(/\\W/g, '')\n          let invalidKey = false\n\n          // check if the key is still invalid and fallback to using a known\n          // safe key\n          if (cleanedKey.length === 0 || cleanedKey.length > 30) {\n            invalidKey = true\n          }\n          if (!isNaN(parseInt(cleanedKey.substr(0, 1)))) {\n            invalidKey = true\n          }\n\n          if (invalidKey) {\n            cleanedKey = getSafeRouteKey()\n          }\n\n          routeKeys[cleanedKey] = key\n          return repeat\n            ? optional\n              ? `(?:/(?<${cleanedKey}>.+?))?`\n              : `/(?<${cleanedKey}>.+?)`\n            : `/(?<${cleanedKey}>[^/]+?)`\n        } else {\n          return `/${escapeRegex(segment)}`\n        }\n      })\n      .join('')\n\n    return {\n      re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n      groups,\n      routeKeys,\n      namedRegex: `^${namedParameterizedRoute}(?:/)?$`,\n    }\n  }\n\n  return {\n    re: new RegExp(`^${parameterizedRoute}(?:/)?$`),\n    groups,\n  }\n}\n"]},"metadata":{},"sourceType":"script"}