{"ast":null,"code":"\"use strict\";\n\nexports.__esModule = true;\nexports.getRouteMatcher = getRouteMatcher;\n\nfunction getRouteMatcher(routeRegex) {\n  var re = routeRegex.re,\n      groups = routeRegex.groups;\n  return function (pathname) {\n    var routeMatch = re.exec(pathname);\n\n    if (!routeMatch) {\n      return false;\n    }\n\n    var decode = function decode(param) {\n      try {\n        return decodeURIComponent(param);\n      } catch (_) {\n        var err = new Error('failed to decode param');\n        err.code = 'DECODE_FAILED';\n        throw err;\n      }\n    };\n\n    var params = {};\n    Object.keys(groups).forEach(function (slugName) {\n      var g = groups[slugName];\n      var m = routeMatch[g.pos];\n\n      if (m !== undefined) {\n        params[slugName] = ~m.indexOf('/') ? m.split('/').map(function (entry) {\n          return decode(entry);\n        }) : g.repeat ? [decode(m)] : decode(m);\n      }\n    });\n    return params;\n  };\n}","map":{"version":3,"sources":["../../../../../next-server/lib/router/utils/route-matcher.ts"],"names":["pathname","routeMatch","re","decode","param","decodeURIComponent","err","params","Object","slugName","g","groups","m","entry"],"mappings":";;;;;AAEO,SAAA,eAAA,CAAA,UAAA,EAAuE;AAAA,MACtE,EADsE,GAC5E,UAD4E,CACtE,EADsE;AAAA,MACtE,MADsE,GAC5E,UAD4E,CACtE,MADsE;AAE5E,SAAQA,UAAAA,QAAD,EAAyC;AAC9C,QAAMC,UAAU,GAAGC,EAAE,CAAFA,IAAAA,CAAnB,QAAmBA,CAAnB;;AACA,QAAI,CAAJ,UAAA,EAAiB;AACf,aAAA,KAAA;AAGF;;AAAA,QAAMC,MAAM,GAAIC,SAAVD,MAAUC,CAAAA,KAAD,EAAmB;AAChC,UAAI;AACF,eAAOC,kBAAkB,CAAzB,KAAyB,CAAzB;AACA,OAFF,CAEE,OAAA,CAAA,EAAU;AACV,YAAMC,GAA8B,GAAG,IAAA,KAAA,CAAvC,wBAAuC,CAAvC;AAGAA,QAAAA,GAAG,CAAHA,IAAAA,GAAAA,eAAAA;AACA,cAAA,GAAA;AAEH;AAVD,KAAA;;AAWA,QAAMC,MAAkD,GAAxD,EAAA;AAEAC,IAAAA,MAAM,CAANA,IAAAA,CAAAA,MAAAA,EAAAA,OAAAA,CAA6BC,UAAAA,QAAD,EAAsB;AAChD,UAAMC,CAAC,GAAGC,MAAM,CAAhB,QAAgB,CAAhB;AACA,UAAMC,CAAC,GAAGX,UAAU,CAACS,CAAC,CAAtB,GAAoB,CAApB;;AACA,UAAIE,CAAC,KAAL,SAAA,EAAqB;AACnBL,QAAAA,MAAM,CAANA,QAAM,CAANA,GAAmB,CAACK,CAAC,CAADA,OAAAA,CAAD,GAACA,CAAD,GACfA,CAAC,CAADA,KAAAA,CAAAA,GAAAA,EAAAA,GAAAA,CAAkBC,UAAAA,KAAD;AAAA,iBAAWV,MAAM,CADnB,KACmB,CAAjB;AAAA,SAAjBS,CADe,GAEfF,CAAC,CAADA,MAAAA,GACA,CAACP,MAAM,CADPO,CACO,CAAP,CADAA,GAEAP,MAAM,CAJVI,CAIU,CAJVA;AAMH;AAVDC,KAAAA;AAWA,WAAA,MAAA;AA9BF,GAAA;AAgCD","sourcesContent":["import { getRouteRegex } from './route-regex'\n\nexport function getRouteMatcher(routeRegex: ReturnType<typeof getRouteRegex>) {\n  const { re, groups } = routeRegex\n  return (pathname: string | null | undefined) => {\n    const routeMatch = re.exec(pathname!)\n    if (!routeMatch) {\n      return false\n    }\n\n    const decode = (param: string) => {\n      try {\n        return decodeURIComponent(param)\n      } catch (_) {\n        const err: Error & { code?: string } = new Error(\n          'failed to decode param'\n        )\n        err.code = 'DECODE_FAILED'\n        throw err\n      }\n    }\n    const params: { [paramName: string]: string | string[] } = {}\n\n    Object.keys(groups).forEach((slugName: string) => {\n      const g = groups[slugName]\n      const m = routeMatch[g.pos]\n      if (m !== undefined) {\n        params[slugName] = ~m.indexOf('/')\n          ? m.split('/').map((entry) => decode(entry))\n          : g.repeat\n          ? [decode(m)]\n          : decode(m)\n      }\n    })\n    return params\n  }\n}\n"]},"metadata":{},"sourceType":"script"}